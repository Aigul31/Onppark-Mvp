Эндпоинт /api/messages (GET, POST)
api/messages.js
// api/messages.js
const { getAdminClient } = require('./_supabaseAdmin');

module.exports = async (req, res) => {
  const supabase = getAdminClient();

  if (req.method === 'GET') {
    const { thread_id } = req.query || {};
    let q = supabase.from('messages').select('*').order('created_at', { ascending: false }).limit(100);
    if (thread_id) q = q.eq('thread_id', thread_id);

    const { data, error } = await q;
    if (error) return res.status(500).json({ error: error.message });
    return res.status(200).json(data);
  }

  if (req.method === 'POST') {
    const { data, error } = await supabase.from('messages').insert(req.body).select();
    if (error) return res.status(400).json({ error: error.message });
    return res.status(201).json(data?.[0] ?? null);
  }

  res.setHeader('Allow', 'GET, POST');
  return res.status(405).end('Method Not Allowed');
};
Шаг 7. Эндпоинт загрузки /api/objects/upload (POST → Supabase Storage)
api/objects/upload.js
// api/objects/upload.js
const { getAdminClient } = require('../_supabaseAdmin');
const Busboy = require('busboy');

// Отключаем json-парсер для этого роута — Vercel будет отдавать сырое тело
module.exports.config = {
  api: { bodyParser: false },
};

function parseMultipart(req) {
  return new Promise((resolve, reject) => {
    const bb = Busboy({ headers: req.headers });
    const files = [];
    bb.on('file', (_name, file, info) => {
      const chunks = [];
      file.on('data', (d) => chunks.push(d));
      file.on('end', () => {
        files.push({
          filename: info.filename,
          mime: info.mimeType || info.mime || 'application/octet-stream',
          buffer: Buffer.concat(chunks),
        });
      });
    });
    bb.on('finish', () => resolve({ files }));
    bb.on('error', reject);
    req.pipe(bb);
  });
}

module.exports = async (req, res) => {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).end('Method Not Allowed');
  }

  const supabase = getAdminClient();

  try {
    const { files } = await parseMultipart(req);
    if (!files?.length) return res.status(400).json({ error: 'No file' });

    const file = files[0];
    const ext = (file.filename.split('.').pop() || 'jpg').toLowerCase();
    const path = `uploads/${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`;

    const { data, error } = await supabase
      .storage
      .from('avatars') // ← назови свой bucket
      .upload(path, file.buffer, { contentType: file.mime, upsert: false });

    if (error) return res.status(500).json({ error: error.message });

    const { data: pub } = supabase.storage.from('avatars').getPublicUrl(path);
    return res.status(200).json({ path, url: pub?.publicUrl ?? null });
  } catch (e) {
    return res.status(500).json({ error: String(e?.message || e) });
  }
};
В Supabase Storage заранее создай bucket (например, avatars). Можешь сделать его Public для простоты теста (или оставить Private и раздавать signed URL).
Шаг 8. Обнови фронтенд вызовы
В тех местах, где ты обращалась к старому server.js или Replit Object Storage — теперь зови свои пути:
/api/profiles
/api/status
/api/messages
/api/objects/upload
Пример функции загрузки фото на клиенте:
async function uploadPhoto(file) {
  const form = new FormData();
  form.append('file', file);

  const resp = await fetch(`${window.APP_CONFIG.API_BASE}/api/objects/upload`, {
    method: 'POST',
    body: form,
  });
  if (!resp.ok) throw new Error('Upload failed');
  return resp.json(); // { url, path }
}