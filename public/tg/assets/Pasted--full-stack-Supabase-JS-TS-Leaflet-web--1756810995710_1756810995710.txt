Ты — инженер-агент (full-stack, Supabase + JS/TS, Leaflet), с доступом к репозиторию проекта (web + backend API/Edge Functions) и к Supabase (SQL, RLS, Logs). Твоя задача — починить сохранение статусов реальных пользователей и их отображение на карте, чтобы пользователи видели друг друга и могли открывать профиль, как это уже работает для фейковых точек.
Цель (Definition of Done)
Реальные пользователи могут опубликовать статус (кофе/прогулка/путешествие), привязанный к выбранной геолокации.
Другие пользователи видят эти статусы на карте (без необходимости логина в веб, если это текущая модель), метки корректно рендерятся.
По клику на метку открывается карточка профиля с именем (поле name, не display_name) и базовыми данными.
Вставка и чтение статусов используют один и тот же источник данных (один Supabase-проект/таблица).
Есть автотест/скрипт проверки и подробные логи; PR с миграциями и инструкцией по деплою.
Текущий контекст/наблюдения
Таблицы: public.statuses, public.profiles, а также messages, connection.
Ранее была путаница message vs massage, типы полей (user_id как text, id как int8), RLS-политики.
Отображение имени должно идти из profiles.name.
Часть логики «аутентификация по email» на веб-экране статуса удалена, сейчас сохранение идёт через backend API.
Симптом: второй реальный аккаунт не видит статусы первого на карте.
Ограничения и политика безопасности
Не ломай прод: делай работы в ветке fix/statuses-map-visibility.
Перед DDL-миграциями сделай экспорт таблиц public.statuses и public.profiles.
RLS: чтение можно открыть для anon (если веб должен быть «read-only»), вставку — через backend с service-role (Edge Function/API) или через authenticated (если останется логин).
План работ (обязательные шаги)
A) Диагностика «пишем/читаем одно и то же»
Сравни ENV фронта и бэка: Supabase URL/ANON/SERVICE ключи → должны указывать на один проект.
Проверь, куда пишет API: зафиксируй лог INSERT в public.statuses при публикации статуса (Supabase → Logs PostgREST/SQL или лог бэка).
Выполни SQL, чтобы увидеть последние записи и типы:
select id, user_id, latitude, longitude, message, created_at
from public.statuses
order by created_at desc
limit 50;
Убедись, что обе учётки там есть и что координаты в допустимых диапазонах.
B) Схема и RLS (под текущую модель)
Приведи таблицу public.statuses к виду:
id bigserial pk, user_id text not null,
latitude double precision not null, longitude double precision not null,
message text, icon text, location text,
created_at timestamptz default now().
Если есть опечатка massage — переименуй в message.
Включи RLS и проверь политики:
SELECT для anon (если веб без логина):
create policy statuses_select_public on public.statuses for select to anon using (true);
(Параллельно может быть to authenticated using (true).)
INSERT: если вставка идёт через backend с service-role, то прямые клиентские insert не нужны; иначе оставь:
create policy statuses_insert_own on public.statuses for insert to authenticated with check (auth.uid()::text = user_id);
В public.profiles проверь поле name (nullable и используется в UI), при необходимости добавь name text и синхронизируй отображение.
C) Backend API/Edge Function
Убедись, что один эндпоинт отвечает за создание статуса, и он пишет именно в public.statuses текущего проекта.
Убери любые фильтры «только мои» в GET-эндпоинте. Допусти параметры:
?since=ISO8601 (по умолчанию 48 часов),
?bbox=minLng,minLat,maxLng,maxLat (фильтрация по области экрана),
?status=coffee|walk|travel (по желанию).
В ответе GET отдавай минимум:
id, user_id, latitude, longitude, message, icon, location, created_at + сджойненный profiles.name/avatar_url (или отдельный запрос профиля).
Логи: при POST логируй user_id, координаты, время; при GET — количество строк и активные фильтры.
D) Frontend (карта/рендер)
Источник данных — только новый GET эндпоинт.
Перед рендером явно приведи координаты к числам:
lat = Number(s.latitude); lng = Number(s.longitude);
и фильтруй Number.isFinite(lat) && Number.isFinite(lng).
Покажи счётчик «N статусов загружено» и выведи первые 3 записи в консоль для отладки.
По клику на маркер открывай попап с name из profiles (или подтянуть по user_id).
E) Тесты / Приёмка
Сценарий «два профиля»: создать статус профиля A и профиля B в разных координатах → оба видят друг друга.
Сценарий «bbox + since»: при сужении карты количество статусов сокращается; при since 10 минут старые не приходят.
Сценарий «пустые координаты/строки»: backend отклоняет/нормализует; фронт не падает.
RLS: из браузера без токена select работает, insert — только через backend (или через логин, если так задумано).
Ожидаемые артефакты в PR
Миграция SQL: создание/правки public.statuses, политики RLS, индексы (created_at, (latitude, longitude)).
Изменения в backend: единый POST /api/statuses, единый GET /api/statuses (с фильтрами), логи.
Изменения во фронте: использование единого GET, приведение типов, попап профиля, удаление устаревших модалок/входа на странице статуса.
README_FIX.md: как деплоить, какие ENV важны (Supabase URL/keys, базовый API URL), как прогнать тест-скрипт e2e (curl/Postman).
Короткий скрипт/коллекция запросов для проверки (2 пользователя → 2 статуса → оба видны).
Подсказки агенту (типичные причины бага)
Несовпадение ENV: фронт/бэк/Edge Function смотрят в разные Supabase проекты.
GET по ошибке фильтрует по user_id текущего пользователя.
Координаты приходят строками → фронт их отбрасывает и не рисует.
Слишком жёсткие фильтры времени (since=10m).
Поле имени берётся из display_name, а хранится в name.
Опечатка колонки massage вместо message.
Метрики успеха
P50 ответ GET /api/statuses < 150 мс,
≥ 2 видимых статуса из разных аккаунтов в пределах 5 км,
0 ошибок в консоли фронта, 0 ошибок вставки в логах за 15 минут теста.